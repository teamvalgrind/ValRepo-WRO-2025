
---

# Equipo [Team ValGrind]
# WRO 2025

[![SAVE-20250527-193558.jpg](https://i.postimg.cc/VvXNFbns/SAVE-20250527-193558.jpg)](https://postimg.cc/fSTZzy81)
---

##  √çndice

1. [Nuestro Equipo](#nuestro-equipo)
    - [Integrantes](#integrantes)
    - [Or√≠genes](#origenes)
2. [Nuestro Objetivo](#nuestro-objetivo)
3. [El Robot](#el-robot)
    - [Apartado Mec√°nico](#apartado-mec√°nico)
        - [Movilidad](#movilidad)
        - [Chasis e Impresi√≥n 3D](#chasis-e-impresi√≥n-3d)
    - [Apartado Electr√≥nico](#apartado-electr√≥nico)
        - [Bater√≠as](#bater√≠as)
        - [Sensores Ultras√≥nicos](#sensores-ultras√≥nicos)
        - [Conexiones y Circuitos](#conexiones-y-circuitos)
        - [Microcontroladores](#microcontroladores)
    - [Apartado Program√°tico](#apartado-program√°tico)
        - [C√≥digo por Componente](#c√≥digo-por-componente)
        - [Diagramas de Flujo](#diagramas-de-flujo)
        - [Algoritmos y Teor√≠a](#algoritmos-y-teor√≠a)
        - [Compiladores y Comunicaci√≥n](#compiladores-y-comunicaci√≥n)
4. [Recursos para Hacer el Robot](#recursos-para-hacer-el-robot)
5. [Licencia](#licencia)

---

## Nuestro Equipo

<img src="https://github.com/damuec/ValRepo1/assets/foto-equipo.jpg" alt="Foto del equipo" width="400"/>

Somos **[Team ValGrind]**, entusiastas de la rob√≥tica y la innovaci√≥n. Representamos a nuestra instituci√≥n en la fase regional de la **WRO 2025**, con la meta de clasificar a la nacional.

En esta primera secci√≥n , se encuentra toda la informaci√≥n b√°sica acerca de nuestro equipo, desde nuestros or√≠genes hasta nuestros planes para poder lograr todas nuestras metas.
    -[Integrantes]
     Samuel Burgos 
     _png_
     17 a√±os, 09/01/2008
     Un resumen corto


-  [Instituci√≥n]: [https://www.instagram.com/colegiosaltoangel]
-  [Instagram Oficial]:
(https://instagram.com/team_valgrind)
-  [Cont√°ctanos]: [valgrind2025@gmail.com]

## Nuestros Origenes

El nombre de nuestro equipo fue decidido por los 3 a partir de un cl√°sico compilador de C++ llamado de la misma forma, el cual es representado por un logotipo des√©rtico y un drag√≥n rojo hecho mediante origami. Al mismo tiempo, tanto el apartado est√©tico como la identidad de nuestro equipo tambi√©n muestra simbolismos y elementos de la mitolog√≠a n√≥rdica, raz√≥n por la cual tambi√©n decidimos que nuestro robot se llamara "Heimdall", ya que no solo es un gui√±o a la mitolog√≠a n√≥rdica en cuesti√≥n sino que tambi√©n cabe destacar que su personaje es un dios en la mitolog√≠a n√≥rdica, conocido como el guardi√°n de las puertas de Asgard y el puente Bifr√∂st, que conecta los Nueve Mundos. y asimismo Tambi√©n es responsable de anunciar el inicio del Ragnar√∂k. Al ser un personaje imponente, fue elegido como el nombre que representar√° a nuestro proyecto dentro de la World Robotic Olympiad 2025 (WRO)

<foto del robot>

---

## Nuestro Objetivo

Dise√±ar, construir y programar un robot aut√≥nomo capaz de superar los desaf√≠os de la WRO 2025, utilizando innovaci√≥n y trabajo en equipo para lograr un desempe√±o sobresaliente en la etapa regional y avanzar a la nacional. Para llegar a esto, hemos pasado los √∫ltimos meses dise√±ando, construyendo, armando y programando nuestro m√°s nuevo proyecto "Heimdall" 

 La World Robot Olympiad (WRO) es una competencia internacional de rob√≥tica educativa que se desarrolla en varias fases, y nuestro equipo l√≥gicamente tiene que comenzar por la fase regional, mediante la cual al ganarla se accede a la Fase Nacional. Cada pa√≠s organiza su propio torneo clasificatorio, donde equipos de j√≥venes compiten en distintas categor√≠as, aplicando conocimientos de rob√≥tica y STEAM. Por √∫ltimo, la fase a la cual nuestro equipo quiere llegar es la Final Internacional. Los equipos ganadores de cada pa√≠s participan en la competencia global, donde enfrentan desaf√≠os m√°s complejos y compiten con representantes de m√°s de 95 pa√≠ses
    - _foto wro_
    - A√∫n as√≠, nuestro √∫nico objetivo no es solamente ganar, como un equipo unido tambi√©n tenemos la convicci√≥n de poder crear un robot no solo funcional, sino que llene nuestras expectativas; A pesar de ser intangible nuestro deseo de poder culminar nuestro proyecto como un equipo unido y verlo brillar, tambi√©n es una meta importante para nosotros.

---

## El Robot

### Apartado Mec√°nico

#### Movilidad

Nuestro robot emplea un sistema de tracci√≥n diferencial, ofreciendo maniobrabilidad precisa para enfrentar los retos del campo de competencia. El sistema de cruces se realiza mediante un servo que ajusta la direcci√≥n del robot en intersecciones cr√≠ticas.

#### Chasis e Impresi√≥n 3D

Fusion 360 es una plataforma de software de modelado 3D, CAD, CAM, CAE y PCB basada en la nube destinada al dise√±o y la fabricaci√≥n de productos. Nos permite dise√±ar y crear productos de acuerdo a sus especificaciones particulares, garantizando que cada pieza cumpla con los m√°s exigentes criterios de est√©tica, forma, ajuste y funcionalidad. Adem√°s, incorpora un conjunto integral de herramientas avanzadas para el dise√±o de placas de circuito impreso y componentes electr√≥nicos, lo que facilita la conceptualizaci√≥n y materializaci√≥n de cualquier idea, incluso las m√°s complejas. Al implementar estas funciones, la plataforma optimiza significativamente tanto el tiempo como los costos asociados, asegurando que el proceso de producci√≥n se realice de manera eficiente y que las piezas obtenidas sean de la m√°s alta calidad. Nosotros usamos esta herramienta gr√°fica y de dise√±o para poder realizar los dise√±os del chasis y aquellas piezas personalizadas para nuestro robot

![Chasis 3D](https://github.com/damuec/ValRepo1/assets/chasis-3d.png)

---

### Apartado Electr√≥nico

#### Bater√≠as

Para el proyecto, decidimos usar dos bater√≠as:

- La primera, se trata de un paquete de 2 bater√≠as recargables de 12 V con una capacidad nominal de 2000 mAh cada una. Utilizan tecnolog√≠a de n√≠quel-metal hidruro (NiMH), lo que elimina el efecto memoria y garantiza que, a pesar de repetidos ciclos de carga y descarga, la capacidad de energ√≠a se conserve de forma √≥ptima. Con dimensiones aproximadas de 50 x 29 x 72 mm y cableado con cables desnudos, la bater√≠a permite una integraci√≥n vers√°til y directa, lo cual nos facilita integrarlo dentro de nuestro proyecto sin que inmiscuya con el rendimiento de otros componentes, o con el dise√±o del mismo

<foto>

- La segunda, se trata un kit de bater√≠as recargables Tenergy de tecnolog√≠a NiMH, dise√±ado para ofrecer una salida estable de 12 V y una capacidad de 2000 mAh por unidad en un formato compacto y robusto, que facilita su integraci√≥n en proyectos de electr√≥nica y rob√≥tica gracias a sus cables desnudos para conexiones directas; garantizando una carga r√°pida y un suministro energ√©tico continuo y fiable, este kit, a nuestro parecer resulta ideal para aplicaciones exigentes como las competencias de rob√≥tica en nuestra categor√≠a , donde es imperativo optimizar tanto el rendimiento del sistema como los tiempos de montaje y costos operativos. 

<fotos>

#### Sensores Ultras√≥nicos

El robot cuenta con m√∫ltiples sensores ultras√≥nicos (HC-SR04 para ser espec√≠ficos) ubicados estrat√©gicamente para la detecci√≥n de obst√°culos y el c√°lculo de distancias, permitiendo navegaci√≥n aut√≥noma y segura. El sensor en cuesti√≥n, es un sensor de distancia de bajo costo, por lo que su uso es muy frecuente en la rob√≥tica. Este incorpora un par de transductores de ultrasonido que se utilizan de manera conjunta para determinar la distancia del sensor con un objeto colocado enfrente de este. Un transductor emite una ‚Äúr√°faga‚Äù de ultrasonido y el otro capta el rebote de dicha onda.

El tiempo que tarda la onda sonora en ir y regresar a un objeto puede utilizarse para conocer la distancia que existe entre el origen del sonido y el objeto. La interfaz del sensor HC-SR04 y Arduino se logra mediante 2 pines digitales: el pin de disparo (trigger) y eco (echo). La funci√≥n de cada uno de estos pines es la siguiente:

El pin trigger recibe un pulso de habilitaci√≥n de parte del microcontrolador, mediante el cual se le indica al m√≥dulo que comience a realizar la medici√≥n de distancia.
En el pin echo el sensor devuelve al microcontrolador un puso cuyo ancho es proporcional al tiempo que tarda el sonido en viajar del transductor al obst√°culo y luego de vuelta al m√≥dulo.

#### Conexiones y Circuitos

Todos los m√≥dulos est√°n conectados en un circuito organizado, minimizando interferencias y facilitando el mantenimiento.  

[Ver diagrama del circuito](./docs/diagrama-electronico.png)


#### Microcontroladores

esp-32.

---

### Apartado Program√°tico

/*
  C√≥digo de Heimdall para la categor√≠a futuros ingenieros de la WRO 2025
  Hecho por Cristobal Mogollon y Samuel Burgos

  El c√≥digo hace que el robot al prenderse avance y de 3 vueltas a la pista
  de futuros ingenieros en la etapa abierta y al completar la cantidad de 12
  giros a la pista avanzar√° dos segundos m√°s y se detiene autom√°ticamente

  Version del codigo: 5
  En esta version del codigo se cambia de placa pasamos de usar un arduino 
  mega a cambiar a esp32 por el tema de la diferencia de tama√±o entre ambas 
  la esp32 al ser mas peque√±a reducimos peso y ahorramos mas espacio tambien 
  cuenta con la ventaja de la memoria que es mas extensa a la de un arduino mega

  Mayo 23 2025
  11:30 AM
*/

#include <Wire.h>              
#include <Ultrasonic.h>
#include <ESP32Servo.h>        // Librer√≠a para ESP32
#include <Adafruit_BNO08x.h>   

// Configuraci√≥n de pines ESP32
#define USTFRONT 13     // GPIO13 como Trigger frontal
#define USEFRONT 12     // GPIO12 como Echo frontal
#define USTLEFT 14      // GPIO14 como Trigger izquierdo
#define USELEFT 27      // GPIO27 como Echo izquierdo
#define USTRIGHT 26     // GPIO26 como Trigger derecho
#define USERIGHT 25     // GPIO25 como Echo derecho

// Pines para servos y ESC
#define PIN_ESC 18      // GPIO18 para ESC
#define PIN_SERVO 19    // GPIO19 para servo direccional

Ultrasonic USFront(USTFRONT, USEFRONT);
Ultrasonic USLeft(USTLEFT, USELEFT);
Ultrasonic USRight(USTRIGHT, USERIGHT);

const int DISTANCIA_OBSTACULO_FRONTAL = 15;
const int DISTANCIA_OBSTACULO_LATERAL = 50;

Servo esc;
Servo myservo;

int pos = 85;
bool motorEnMarcha = false;
int contadorVueltas = 0;
bool giroDetectado = false;
bool robotDetenido = false;

// BNO085 (I2C personalizado)
#define SDA_PIN 21      // GPIO21 como SDA
#define SCL_PIN 22      // GPIO22 como SCL
Adafruit_BNO08x bno08x;
sh2_SensorValue sensorValue;

float anguloAcumuladoZ = 0.0;
unsigned long tiempoAnterior = 0;

void setup() {
  Wire.begin(SDA_PIN, SCL_PIN);  // Inicializar I2C con pines espec√≠ficos
  esc.attach(PIN_ESC, 1000, 2000);
  myservo.attach(PIN_SERVO);
  Serial.begin(115200);

  // Inicializar BNO085
  if (!bno08x.begin_I2C(0x4B, &Wire)) {
    Serial.println("¬°No se pudo iniciar el BNO08x!");
    while(1);
  }
  bno08x.enableReport(SH2_GYROSCOPE_CALIBRATED, 10000);

  // Armar el ESC al iniciar
  esc.write(90);
  delay(3000);

  tiempoAnterior = millis();
}

void loop() {
  doceVueltas();
}

void doceVueltas() {
  if (robotDetenido) {
    // Robot detenido, no hacer nada m√°s
    return;
  }

  int frontal = USFront.read();
  int izquierda = USLeft.read();
  int derecha = USRight.read();

  // Leer datos del giroscopio del BNO085 y acumular el √°ngulo girado en el eje Z
  unsigned long tiempoActual = millis();
  float deltaTime = (tiempoActual - tiempoAnterior) / 1000.0; // segundos
  tiempoAnterior = tiempoActual;

  if (bno08x.getSensorEvent(&sensorValue)) {
    if (sensorValue.sensorId == SH2_GYROSCOPE_CALIBRATED) {
      float gyroZ = sensorValue.un.gyroscope.z * 57.3; // Convertir a dps
      anguloAcumuladoZ += gyroZ * deltaTime; // Acumula el √°ngulo en el eje Z (con signo)
    }
  }

  // Si el √°ngulo acumulado supera +89¬∞ o -89¬∞, cuenta como un giro
  if (abs(anguloAcumuladoZ) > 89) {
    contadorVueltas++;
    // (Opcional) Muestra el sentido del giro
    if (anguloAcumuladoZ > 0) {
      Serial.print("Giro a la derecha detectado. ");
    } else {
      Serial.print("Giro a la izquierda detectado. ");
    }
    anguloAcumuladoZ = 0; // Resetea el acumulador
    Serial.print("Giros: ");
    Serial.println(contadorVueltas);
  }

  Serial.print("Frontal: "); Serial.print(frontal);
  Serial.print("cm | Izq: "); Serial.print(izquierda);
  Serial.print("cm | Der: "); Serial.print(derecha);
  Serial.print("cm | √Ångulo acumulado Z: ");
  Serial.println(anguloAcumuladoZ);

  if (frontal > DISTANCIA_OBSTACULO_FRONTAL) {
    if (!motorEnMarcha) {
      Adelante();
      motorEnMarcha = true;
    }
  } else {
    if (motorEnMarcha) {
      Parar();
      motorEnMarcha = false;
    }

    if (izquierda > DISTANCIA_OBSTACULO_LATERAL && izquierda > derecha) {
      Izquierda();
    } else if (derecha > DISTANCIA_OBSTACULO_LATERAL && derecha > izquierda) {
      Derecha();
    } else {
      Atras();
      delay(500);
      Parar();
    }
    delay(1000);
    myservo.write(90);
  }

  // Si contadorVueltas llega a 12, avanzar 2 segundos y parar
  if (contadorVueltas >= 12) {
    Adelante(); // Avanzamos
    delay(2000);  // Esperamos 2 segundos
    Parar();    // Detenemos el motor
    Serial.println("¬°Completados 12 giros!");
    robotDetenido = true;  // Bloquea para que no siga ejecutando
  }
}

void Atras(){
  Serial.println("Armando ESC...");
  esc.write(90);     // Pulso m√≠nimo para armar ESC
  delay(10);         // Espera breve para armar

  Serial.println("Aumentando velocidad...");
  for (int speed = 90; speed <= 130; speed += 10) {
    esc.write(speed);
    Serial.print("Velocidad: ");
    Serial.println(speed);
    delay(250);
  }
  
  Serial.println("Manteniendo velocidad fija");
  esc.write(130);     // Mantiene velocidad fija
}

void Adelante(){
  Serial.println("Aumentando velocidad hacia atr√°s...");
  esc.write(90);     // Pulso m√≠nimo para armar ESC
  delay(10);
  for (int speed = 90; speed >= 30; speed -= 10) { 
    esc.write(speed);
    Serial.print("Velocidad atr√°s: ");
    Serial.println(speed);
    delay(250);
  }
  Serial.println("Manteniendo velocidad fija hacia atr√°s");
  esc.write(30);      // Mantiene velocidad fija hacia atr√°s
}

void Parar() {
  Serial.println("Deteniendo motor...");
  esc.write(90);  // Pulso m√≠nimo para detener el motor (igual que armar)
}

void Derecha() {
  Serial.println("Motor en marcha y girando a la derecha gradualmente...");

  esc.write(90);      // Armar motor
  delay(10);

  esc.write(130);     // Velocidad fija

  for (int ang = 85; ang <= 180; ang++) {
    myservo.write(ang);
    Serial.print("√Ångulo servo: ");
    Serial.println(ang);
    delay(1);
  }

  myservo.write(90);
  esc.write(90);
  Serial.println("Giro completado");
}

void Izquierda() {
  Serial.println("Motor en marcha y girando a la Izquierda gradualmente...");

  esc.write(90);      // Armar motor
  delay(10);

  esc.write(130);     // Velocidad fija

  for (int ang = 85; ang >= 0; ang--) {
    myservo.write(ang);
    Serial.print("√Ångulo servo: ");
    Serial.println(ang);
    delay(1);
  }

  myservo.write(90);
  esc.write(90);
  Serial.println("Giro completado");
}

#### Diagramas de Flujo

[![IMG-20250523-WA0008.jpg](https://i.postimg.cc/QxYhNwBT/IMG-20250523-WA0008.jpg)](https://postimg.cc/YhFJbXzr)


#### Compiladores y Comunicaci√≥n

- **Lenguaje principal:** C++ (Arduino IDE)
- **Compilador:** [Arduino IDE](https://www.arduino.cc/en/software)
- **Comunicaci√≥n entre m√≥dulos:** Bus I2C y UART

---

## üõí Recursos para Hacer el Robot

- [Lista de materiales detallada](./docs/lista-componentes.md)
- [Gu√≠a de armado paso a paso](./docs/guia-armado.md)
- [Archivos STL para impresi√≥n 3D](./3d/)

---

## ‚öñÔ∏è Licencia

Este proyecto est√° licenciado bajo la [MIT License](./LICENSE).

---

> _¬øQuieres contribuir o seguir nuestro avance? S√≠guenos en nuestras redes oficiales y revisa este repositorio para novedades y recursos._

---
