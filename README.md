
---

# Equipo [Team ValGrind] ‚Äì WRO 2025

<img src="https://github.com/damuec/ValRepo1/assets/logo-equipo.png" alt="Logo del equipo" width="200"/>

---

##  √çndice

1. [Nuestro Equipo](#nuestro-equipo)
    - [Integrantes](#integrantes)
    - [Or√≠genes](#origenes)
2. [Nuestro Objetivo](#nuestro-objetivo)
3. [El Robot](#el-robot)
    - [Apartado Mec√°nico](#apartado-mec√°nico)
        - [Movilidad](#movilidad)
        - [Chasis e Impresi√≥n 3D](#chasis-e-impresi√≥n-3d)
    - [Apartado Electr√≥nico](#apartado-electr√≥nico)
        - [Bater√≠as](#bater√≠as)
        - [Sensores Ultras√≥nicos](#sensores-ultras√≥nicos)
        - [Conexiones y Circuitos](#conexiones-y-circuitos)
        - [Microcontroladores](#microcontroladores)
    - [Apartado Program√°tico](#apartado-program√°tico)
        - [C√≥digo por Componente](#c√≥digo-por-componente)
        - [Diagramas de Flujo](#diagramas-de-flujo)
        - [Algoritmos y Teor√≠a](#algoritmos-y-teor√≠a)
        - [Compiladores y Comunicaci√≥n](#compiladores-y-comunicaci√≥n)
4. [Recursos para Hacer el Robot](#recursos-para-hacer-el-robot)
5. [Licencia](#licencia)

---

## Nuestro Equipo

<img src="https://github.com/damuec/ValRepo1/assets/foto-equipo.jpg" alt="Foto del equipo" width="400"/>

Somos **[Team ValGrind]**, entusiastas de la rob√≥tica y la innovaci√≥n. Representamos a nuestra instituci√≥n en la fase regional de la **WRO 2025**, con la meta de clasificar a la nacional.

En esta primera secci√≥n , se encuentra toda la informaci√≥n b√°sica acerca de nuestro equipo, desde nuestros or√≠genes hasta nuestros planes para poder lograr todas nuestras metas.
    -[Integrantes]
     Samuel Burgos 
     _png_
     17 a√±os, 09/01/2008
     Un resumen corto


-  [Instituci√≥n]: [https://www.instagram.com/colegiosaltoangel]
-  [Instagram Oficial]:
(https://instagram.com/team_valgrind)
-  [Cont√°ctanos]: [valgrind2025@gmail.com]

## Nuestros Origenes

El nombre de nuestro equipo fue decidido por los 3 a partir de un cl√°sico compilador de C++ llamado de la misma forma, el cual es representado por un logotipo des√©rtico y un drag√≥n rojo hecho mediante origami. Al mismo tiempo, tanto el apartado est√©tico como la identidad de nuestro equipo tambi√©n muestra simbolismos y elementos de la mitolog√≠a n√≥rdica, raz√≥n por la cual tambi√©n decidimos que nuestro robot se llamara "Heimdall", ya que no solo es un gui√±o a la mitolog√≠a n√≥rdica en cuesti√≥n sino que tambi√©n cabe destacar que su personaje es un dios en la mitolog√≠a n√≥rdica, conocido como el guardi√°n de las puertas de Asgard y el puente Bifr√∂st, que conecta los Nueve Mundos. y asimismo Tambi√©n es responsable de anunciar el inicio del Ragnar√∂k. Al ser un personaje imponente, fue elegido como el nombre que representar√° a nuestro proyecto dentro de la World Robotic Olympiad 2025 (WRO)

<foto del robot>

---

## Nuestro Objetivo

Dise√±ar, construir y programar un robot aut√≥nomo capaz de superar los desaf√≠os de la WRO 2025, utilizando innovaci√≥n y trabajo en equipo para lograr un desempe√±o sobresaliente en la etapa regional y avanzar a la nacional. Para llegar a esto, hemos pasado los √∫ltimos meses dise√±ando, construyendo, armando y programando nuestro m√°s nuevo proyecto "Heimdall" 

 La World Robot Olympiad (WRO) es una competencia internacional de rob√≥tica educativa que se desarrolla en varias fases, y nuestro equipo l√≥gicamente tiene que comenzar por la fase regional, mediante la cual al ganarla se accede a la Fase Nacional. Cada pa√≠s organiza su propio torneo clasificatorio, donde equipos de j√≥venes compiten en distintas categor√≠as, aplicando conocimientos de rob√≥tica y STEAM. Por √∫ltimo, la fase a la cual nuestro equipo quiere llegar es la Final Internacional. Los equipos ganadores de cada pa√≠s participan en la competencia global, donde enfrentan desaf√≠os m√°s complejos y compiten con representantes de m√°s de 95 pa√≠ses
    - _foto wro_
    - A√∫n as√≠, nuestro √∫nico objetivo no es solamente ganar, como un equipo unido tambi√©n tenemos la convicci√≥n de poder crear un robot no solo funcional, sino que llene nuestras expectativas; A pesar de ser intangible nuestro deseo de poder culminar nuestro proyecto como un equipo unido y verlo brillar, tambi√©n es una meta importante para nosotros.

---

## El Robot

### Apartado Mec√°nico

#### Movilidad

Nuestro robot emplea un sistema de tracci√≥n diferencial, ofreciendo maniobrabilidad precisa para enfrentar los retos del campo de competencia. El sistema de cruces se realiza mediante un servo que ajusta la direcci√≥n del robot en intersecciones cr√≠ticas.

#### Chasis e Impresi√≥n 3D

Fusion 360 es una plataforma de software de modelado 3D, CAD, CAM, CAE y PCB basada en la nube destinada al dise√±o y la fabricaci√≥n de productos. Nos permite dise√±ar y crear productos de acuerdo a sus especificaciones particulares, garantizando que cada pieza cumpla con los m√°s exigentes criterios de est√©tica, forma, ajuste y funcionalidad. Adem√°s, incorpora un conjunto integral de herramientas avanzadas para el dise√±o de placas de circuito impreso y componentes electr√≥nicos, lo que facilita la conceptualizaci√≥n y materializaci√≥n de cualquier idea, incluso las m√°s complejas. Al implementar estas funciones, la plataforma optimiza significativamente tanto el tiempo como los costos asociados, asegurando que el proceso de producci√≥n se realice de manera eficiente y que las piezas obtenidas sean de la m√°s alta calidad. Nosotros usamos esta herramienta gr√°fica y de dise√±o para poder realizar los dise√±os del chasis y aquellas piezas personalizadas para nuestro robot

![Chasis 3D](https://github.com/damuec/ValRepo1/assets/chasis-3d.png)

---

### Apartado Electr√≥nico

#### Bater√≠as

Para el proyecto, decidimos usar dos bater√≠as:

- La primera, se trata de un paquete de 2 bater√≠as recargables de 12 V con una capacidad nominal de 2000 mAh cada una. Utilizan tecnolog√≠a de n√≠quel-metal hidruro (NiMH), lo que elimina el efecto memoria y garantiza que, a pesar de repetidos ciclos de carga y descarga, la capacidad de energ√≠a se conserve de forma √≥ptima. Con dimensiones aproximadas de 50 x 29 x 72 mm y cableado con cables desnudos, la bater√≠a permite una integraci√≥n vers√°til y directa, lo cual nos facilita integrarlo dentro de nuestro proyecto sin que inmiscuya con el rendimiento de otros componentes, o con el dise√±o del mismo

<foto>

- La segunda, se trata un kit de bater√≠as recargables Tenergy de tecnolog√≠a NiMH, dise√±ado para ofrecer una salida estable de 12 V y una capacidad de 2000 mAh por unidad en un formato compacto y robusto, que facilita su integraci√≥n en proyectos de electr√≥nica y rob√≥tica gracias a sus cables desnudos para conexiones directas; garantizando una carga r√°pida y un suministro energ√©tico continuo y fiable, este kit, a nuestro parecer resulta ideal para aplicaciones exigentes como las competencias de rob√≥tica en nuestra categor√≠a , donde es imperativo optimizar tanto el rendimiento del sistema como los tiempos de montaje y costos operativos. 

<fotos>

#### Sensores Ultras√≥nicos

El robot cuenta con m√∫ltiples sensores ultras√≥nicos (HC-SR04 para ser espec√≠ficos) ubicados estrat√©gicamente para la detecci√≥n de obst√°culos y el c√°lculo de distancias, permitiendo navegaci√≥n aut√≥noma y segura. El sensor en cuesti√≥n, es un sensor de distancia de bajo costo, por lo que su uso es muy frecuente en la rob√≥tica. Este incorpora un par de transductores de ultrasonido que se utilizan de manera conjunta para determinar la distancia del sensor con un objeto colocado enfrente de este. Un transductor emite una ‚Äúr√°faga‚Äù de ultrasonido y el otro capta el rebote de dicha onda.

El tiempo que tarda la onda sonora en ir y regresar a un objeto puede utilizarse para conocer la distancia que existe entre el origen del sonido y el objeto. La interfaz del sensor HC-SR04 y Arduino se logra mediante 2 pines digitales: el pin de disparo (trigger) y eco (echo). La funci√≥n de cada uno de estos pines es la siguiente:

El pin trigger recibe un pulso de habilitaci√≥n de parte del microcontrolador, mediante el cual se le indica al m√≥dulo que comience a realizar la medici√≥n de distancia.
En el pin echo el sensor devuelve al microcontrolador un puso cuyo ancho es proporcional al tiempo que tarda el sonido en viajar del transductor al obst√°culo y luego de vuelta al m√≥dulo.

#### Conexiones y Circuitos

Todos los m√≥dulos est√°n conectados en un circuito organizado, minimizando interferencias y facilitando el mantenimiento.  

[Ver diagrama del circuito](./docs/diagrama-electronico.png)


#### Microcontroladores

esp-32.

---

### Apartado Program√°tico

/*
  C√≥digo de Heimdall para la categor√≠a futuros ingenieros de la WRO 2025
  Hecho por Cristobal Mogollon

  El c√≥digo hace que el robot al prenderse avance y de 3 vueltas a la pista
  de futuros ingenieros en la etapa abierta y al completar la cantidad de 12
  giros a la pista avanzar√° dos segundos m√°s y se detiene autom√°ticamente

  Mayo 21 2025
  5:18 PM

*/

// Incluyendo librer√≠as necesarias
```#include <Wire.h>        // Librer√≠a para I2C
#include <Ultrasonic.h>
#include <Servo.h>
#include <Adafruit_BNO08x.h> // Librer√≠a para el BNO080/BNO085

// Definici√≥n de pines para los sensores ultras√≥nicos
#define USTFRONT 23
#define USEFRONT 22
#define USTRIGHT 45
#define USERIGHT 44
#define USTLEFT 31
#define USELEFT 30

// Creaci√≥n de objetos Ultrasonic para cada sensor
Ultrasonic USFront(USTFRONT, USEFRONT);
Ultrasonic USLeft(USTLEFT, USELEFT);
Ultrasonic USRight(USTRIGHT, USERIGHT);

const int DISTANCIA_OBSTACULO_FRONTAL = 15; // Distancia en cm para el sensor frontal
const int DISTANCIA_OBSTACULO_LATERAL = 50; // Distancia en cm para los sensores laterales

Servo esc;
Servo myservo;

int pos = 85;
bool motorEnMarcha = false;
int contadorVueltas = 0;         // Contador de vueltas
bool giroDetectado = false;       // Para evitar contar el mismo giro varias veces
bool robotDetenido = false;       // Variable para detener el robot despu√©s de 12 giros

// BNO085
Adafruit_BNO08x bno08x;
#define BNO08X_RESET -1           // Si no usas el pin de reset
sh2_SensorValue sensorValue;

void setup() {
  Wire.begin();                    // Inicializa la comunicaci√≥n I2C para el BNO085 en Arduino Mega
  esc.attach(9, 1000, 2000);
  myservo.attach(11);
  Serial.begin(115200);

  // Inicializar el BNO085
  if (!bno08x.begin_I2C()) {
    Serial.println("¬°No se pudo iniciar el BNO08x!");
    while (1) delay(1);
  }
  bno08x.enableReport(SH2_GYROSCOPE_CALIBRATED, 10000); // Reporte cada 10ms

  // Armar el ESC al iniciar
  esc.write(90);
  delay(3000);
}

void loop() {
  doceVueltas();
}

void doceVueltas() {
  if (robotDetenido) {
    // Robot detenido, no hacer nada m√°s
    return;
  }

  int frontal = USFront.read();
  int izquierda = USLeft.read();
  int derecha = USRight.read();

  // Leer datos del giroscopio del BNO085
  float gyroZ = 0.0;
  if (bno08x.getSensorEvent(&sensorValue)) {
    if (sensorValue.sensorId == SH2_GYROSCOPE_CALIBRATED) {
      gyroZ = sensorValue.un.gyroscope.z * 57.3; // Convertir a dps
    }
  }

  Serial.print("Frontal: "); Serial.print(frontal);
  Serial.print("cm | Izq: "); Serial.print(izquierda);
  Serial.print("cm | Der: "); Serial.print(derecha);
  Serial.print("cm | GyroZ: "); Serial.println(gyroZ);

  if (frontal > DISTANCIA_OBSTACULO_FRONTAL) {
    if (!motorEnMarcha) {
      Adelante();
      motorEnMarcha = true;
    }
  } else {
    if (motorEnMarcha) {
      Parar();
      motorEnMarcha = false;
    }

    if (izquierda > DISTANCIA_OBSTACULO_LATERAL && izquierda > derecha) {
      Izquierda();
    } else if (derecha > DISTANCIA_OBSTACULO_LATERAL && derecha > izquierda) {
      Derecha();
    } else {
      Atras();
      delay(500);
      Parar();
    }
    delay(1000);
    myservo.write(90);
  }

  // Calcular el n√∫mero de vueltas (simplificado)
  // Usamos una variable giroDetectado para evitar contar el mismo giro varias veces
  if (abs(gyroZ) > 50 && !giroDetectado) { // Ajustar este valor seg√∫n la sensibilidad del giroscopio
    giroDetectado = true;                   // Marcamos que se ha detectado un giro
    if (gyroZ > 0) {                        // Giro en sentido horario (ejemplo)
      contadorVueltas++;                     // Incrementamos el contador de vueltas
      Serial.print("Vueltas: ");
      Serial.println(contadorVueltas);
    }
  } else if (abs(gyroZ) < 20) {             // Si la velocidad angular es baja, reseteamos giroDetectado
    giroDetectado = false;
  }

  // Si contadorVueltas llega a 12, avanzar 2 segundos y parar
  if (contadorVueltas >= 12) {
    Adelante(); // Avanzamos
    delay(2000);  // Esperamos 2 segundos
    Parar();    // Detenemos el motor
    Serial.println("¬°Completadas 12 vueltas!");
    robotDetenido = true;  // Bloquea para que no siga ejecutando
  }
}

void Adelante(){
  Serial.println("Armando ESC...");
  esc.write(90);     // Pulso m√≠nimo para armar ESC
  delay(10);                     // Espera breve para armar

  Serial.println("Aumentando velocidad...");
  for (int speed = 90; speed <= 130; speed += 10) {
    esc.write(speed);
    Serial.print("Velocidad: ");
    Serial.println(speed);
    delay(250);
  }
  
  Serial.println("Manteniendo velocidad fija");
  esc.write(130);     // Mantiene velocidad fija
}

void Atras(){
  Serial.println("Aumentando velocidad hacia atr√°s...");
  esc.write(90);     // Pulso m√≠nimo para armar ESC
  delay(10);
  for (int speed = 90; speed >= 0; speed -= 50) { 
    esc.write(speed);
    Serial.print("Velocidad atr√°s: ");
    Serial.println(speed);
    delay(200);
  }
  Serial.println("Manteniendo velocidad fija hacia atr√°s");
  esc.write(0);      // Mantiene velocidad fija hacia atr√°s
}

void Parar() {
  Serial.println("Deteniendo motor...");
  esc.write(90);  // Pulso m√≠nimo para detener el motor (igual que armar)
}

void Derecha() {
  Serial.println("Motor en marcha y girando a la derecha gradualmente...");

  esc.write(90);      // Armar motor
  delay(10);

  esc.write(130);     // Velocidad fija

  for (int ang = 85; ang <= 180; ang++) {
    myservo.write(ang);
    Serial.print("√Ångulo servo: ");
    Serial.println(ang);
    delay(1);
  }

  myservo.write(90);
  esc.write(90);
  Serial.println("Giro completado");
}

void Izquierda() {
  Serial.println("Motor en marcha y girando a la Izquierda gradualmente...");

  esc.write(90);      // Armar motor
  delay(10);

  esc.write(130);     // Velocidad fija

  for (int ang = 85; ang >= 0; ang--) {
    myservo.write(ang);
    Serial.print("√Ångulo servo: ");
    Serial.println(ang);
    delay(1);
  }

  myservo.write(90);
  esc.write(90);
  Serial.println("Giro completado");
}
```

#### Diagramas de Flujo

![Diagrama de Flujo](./docs/diagrama-flujo.png)


#### Compiladores y Comunicaci√≥n

- **Lenguaje principal:** C++ (Arduino IDE)
- **Compilador:** [Arduino IDE](https://www.arduino.cc/en/software)
- **Comunicaci√≥n entre m√≥dulos:** Bus I2C y UART

---

## üõí Recursos para Hacer el Robot

- [Lista de materiales detallada](./docs/lista-componentes.md)
- [Gu√≠a de armado paso a paso](./docs/guia-armado.md)
- [Archivos STL para impresi√≥n 3D](./3d/)

---

## ‚öñÔ∏è Licencia

Este proyecto est√° licenciado bajo la [MIT License](./LICENSE).

---

> _¬øQuieres contribuir o seguir nuestro avance? S√≠guenos en nuestras redes oficiales y revisa este repositorio para novedades y recursos._

---
