
# Equipo [Team ValGrind]: WRO 2025

[![SAVE-20250527-193558.jpg](https://i.postimg.cc/VvXNFbns/SAVE-20250527-193558.jpg)](https://postimg.cc/fSTZzy81)

---

## √çndice

1. [Nuestro Equipo](#nuestro-equipo)
    - [Integrantes](#integrantes)
    - [Origenes](#origenes)
    - [Nuestro Objetivo](#nuestro-objetivo)
2. [El Robot](#el-robot)
    - [Apartado Mecanico](#apartado-mecanico)
        - [Impresion 3D](#impresion-3d)
        - [Movilidad](#movilidad)
    - [Apartado Electronico](#apartado-electronico)
        - [Sensores](#sensores)
        - [Conexiones y Circuitos](#conexiones-y-circuitos)
        - [Microcontroladores](#microcontroladores)
    - [Apartado Programatico](#apartado-programatico)
        - [Codigo por Componente](#codigo-por-componente)
4. [Recursos para Hacer el Robot](#recdursos-para-hacer-el-robot)
    - [Mecanica](#mecanica)
    - [Electronica](#electronica)
    - [Programacion](#programacion)

---

## Nuestro Equipo

[![IMG-20250611-WA0013.jpg](https://i.postimg.cc/KvM5HgKW/IMG-20250611-WA0013.jpg)](https://postimg.cc/rKqWdsNG)

Somos **[Team ValGrind]**, entusiastas de la rob√≥tica y la innovaci√≥n. Representamos a nuestra instituci√≥n en la fase regional de la **WRO 2025**.

---

### Integrantes

- **Samuel Burgos**  
  17 a√±os, 09/01/2008  

[![IMG-20250607-044258.jpg](https://i.postimg.cc/Rh55QMjr/IMG-20250607-044258.jpg)](https://postimg.cc/BLgVJGSN)

- **Sebasti√°n Salina**  
  17 a√±os, 22/08/2008 

[![IMG-20250607-043801.jpg](https://i.postimg.cc/Bns7Qb1y/IMG-20250607-043801.jpg)](https://postimg.cc/GH7xXcKJ)

- **Cristobal Mogoll√≥n**
   14 a√±os, 14/07/2010
 [![IMG-20250607-043532.jpg](https://i.postimg.cc/43XVFVRw/IMG-20250607-043532.jpg)](https://postimg.cc/WdfddD3J)

- **Instituci√≥n:** [Colegio Salto √Ångel](https://www.instagram.com/colegiosaltoangel)
- **Instagram Oficial:** [@team_valgrind](https://instagram.com/team_valgrind)
- **Cont√°ctanos:** [valgrind2025@gmail.com](mailto:valgrind2025@gmail.com)

---

### Origenes

El nombre de nuestro equipo fue decidido por los tres integrantes a partir de un cl√°sico compilador de C++ llamado de la misma forma, el cual es representado por un logotipo de un drag√≥n hecho con origami. El nombre "ValGrind" tambi√©n hace referencia a la mitolog√≠a n√≥rdica debido a las legendarias Valquirias que habitan en este.

 [![images-18.jpg](https://i.postimg.cc/dQp02CyM/images-18.jpg)](https://postimg.cc/gryddns4)


> ### ¬øPor qu√© nuestro robot se llama Heimdall?

Este nombre no solo es un gui√±o a la mitolog√≠a mencionada, sino que adem√°s corresponde al dios conocido como el guardi√°n de las puertas de Asgard y del puente Bifr√∂st, que conecta los Nueve Mundos. Al ser un personaje imponente, consideramos que es un nombre apropiado para representar a nuestro robot en la WRO.


## Nuestro Objetivo

[![Logo-wro.png](https://i.postimg.cc/85CCHB4G/Logo-wro.png)](https://postimg.cc/t1LyR68v)

#### "Dise√±ar, Construir y Programar"
 Un robot aut√≥nomo capaz de superar los desaf√≠os de la WRO 2025, utilizando innovaci√≥n y trabajo en equipo para lograr un desempe√±o sobresaliente en la etapa regional y avanzar a la nacional. Para llegar a esto, hemos pasado los √∫ltimos meses dise√±ando, construyendo, armando y programando nuestro m√°s nuevo proyecto "Heimdall"

 
> [!NOTE]
> La World Robot Olympiad (WRO) es una competencia internacional de rob√≥tica educativa que se desarrolla en varias fases, y nuestro equipo l√≥gicamente tiene que comenzar por la fase regional, mediante la cual al ganarla se accede a la Fase Nacional. Cada pa√≠s organiza su propio torneo clasificatorio, donde equipos de j√≥venes compiten en distintas categor√≠as, aplicando conocimientos de rob√≥tica y STEAM. Por √∫ltimo, la fase a la cual nuestro equipo quiere llegar es la Final Internacional. Los equipos ganadores de cada pa√≠s participan en la competencia global, donde enfrentan desaf√≠os m√°s complejos y compiten con representantes de m√°s de 95 pa√≠ses 

[![IMG-20250612-201120.jpg](https://i.postimg.cc/xC9wQTBk/IMG-20250612-201120.jpg)](https://postimg.cc/yJrQXB1B)

A√∫n as√≠, nuestro √∫nico objetivo no es solamente ganar, como un equipo unido tambi√©n tenemos la convicci√≥n de poder crear un robot no solo funcional, sino que llene nuestras expectativas; A pesar de ser intangible nuestro deseo de poder culminar nuestro proyecto como un equipo unido y verlo brillar, tambi√©n es una meta importante para nosotros.

---

## El Robot

[![IMG-20250607-WA0020.jpg](https://i.postimg.cc/prpdddx8/IMG-20250607-WA0020.jpg)](https://postimg.cc/7Jr4sw5Y)

### Apartado Mecanico

| [![Vista Frontal](https://i.postimg.cc/bNvLsHKN/IMG-20250605-192234.jpg)](https://postimg.cc/CdWb2DhW) | [![Vista Trasera](https://i.postimg.cc/44WQkHmC/IMG-20250605-192224.jpg)](https://postimg.cc/xqbzLCvg) | 
| :--: | :--: | 
| *Frontal* | *Posterior* |
|[![IMG-20250605-192216.jpg](https://i.postimg.cc/hjpTBN48/IMG-20250605-192216.jpg)](https://postimg.cc/tZnYdSx7) | [![IMG-20250605-192159.jpg](https://i.postimg.cc/5jdrGfv0/IMG-20250605-192159.jpg)](https://postimg.cc/V0g40QKQ) | 
| *Izquierda* | *Derecha* |
|[![IMG-20250605-192001.jpg](https://i.postimg.cc/x84mTdgf/IMG-20250605-192001.jpg)](https://postimg.cc/tnFJBpLw) | ![Bottom](./robot-photos/bottom.png) | 
| *Superior* | *Inferior* |

#### Impresion 3D

Antes de hablar de la movilidad o funcionalidad de nuestro robot, primero hay que explicar nuestros m√©todos de Dise√±o e Impresi√≥n 3D, los cuales se llevaron a cabo mediante Fusion 360


> [!NOTE]
> Fusion 360 es una plataforma de software de modelado 3D, CAD, CAM, CAE y PCB basada en la nube, destinada al dise√±o y la fabricaci√≥n de productos. Nos permite dise√±ar y crear productos de acuerdo a sus especificaciones particulares, garantizando que cada pieza cumpla con los m√°s exigentes criterios de est√©tica, forma, ajuste y funcionalidad. Adem√°s, incorpora un conjunto integral de herramientas avanzadas para el dise√±o de placas de circuito impreso y componentes electr√≥nicos, lo que facilita la conceptualizaci√≥n y materializaci√≥n de cualquier idea, incluso las m√°s complejas. Al implementar estas funciones, la plataforma optimiza significativamente tanto el tiempo como los costos asociados, asegurando que el proceso de producci√≥n se realice de manera eficiente y que las piezas obtenidas sean de la m√°s alta calidad. Nosotros usamos esta herramienta gr√°fica y de dise√±o para realizar los dise√±os del chasis y las piezas personalizadas de nuestro robot.

[![IMG-20250613-WA0053.jpg](https://i.postimg.cc/Pr5b7SVZ/IMG-20250613-WA0053.jpg)](https://postimg.cc/G96s8xCh)

#### Movilidad

Ahora bien, ya habiendo dilucidado como podemos elegir, dise√±ar y imprimir las piezas de nuestro robot, hay que asegurarnos de que este cuente con las herramientas necesarias para moverse y evadir los obst√°culos de la pista.

> [!NOTE]
> Video de Heimdall realizando el Open Challenge
[Video](https://youtu.be/zEmvAiKoWxc)

Nuestro robot emplea un sistema de tracci√≥n diferencial, ofreciendo maniobrabilidad precisa para enfrentar los retos del campo de competencia. El sistema de cruces se realiza mediante un servo que ajusta la direcci√≥n del robot en intersecciones de forma eficaz. Tambi√©n cabe destacar el hecho de que utilizamos una t√©cnica llamada  Ackermann Positivo para emplear el sistema de movilidad de nuestro veh√≠culo.

[![IMG-20250614-WA0001.jpg](https://i.postimg.cc/tJFzTvy2/IMG-20250614-WA0001.jpg)](https://postimg.cc/30JGfBkv)

##### El diferencial de los veh√≠culos, como su nombre lo indica, permite que exista una diferencia en la velocidad de giro entre la rueda interna y la rueda externa del veh√≠culo cuando se da una vuelta o se est√° girando la direcci√≥n. No importa si el veh√≠culo es tracci√≥n trasera o delantera, la funci√≥n es la misma.

[![10a4.jpg](https://i.postimg.cc/K89xJC6v/10a4.jpg)](https://postimg.cc/G4sWpg3Z)

####  Sistema de Movimiento y Tracci√≥n 

Ahondando en lo mencionado anteriormente, Heimdall utiliza lo que normalmente es denominado sistema ackermann positivo, el cual es un sistema derivado del principio de Ackermann, cuyo objetivo es lograr que en curvas la **rueda interior (Œ∏·µ¢) gire m√°s que la exterior (Œ∏‚Çí)** para minimizar deslizamiento lateral (*scrub*).  

- **Ecuaci√≥n fundamental**:  
  **cot(Œ∏‚Çí) - cot(Œ∏·µ¢) = W / L**  
  - *W*: Distancia entre pivotes de direcci√≥n (batalla)  
  - *L*: Distancia entre ejes  
  

### **Implementaci√≥n F√≠sica**
```asciidoc
[Rueda exterior (Œ∏‚Çí)]
  ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ Brazo de direcci√≥n  
  ‚îÇ        \  
[Cuadro]‚îÄ‚îÄ‚î§         \  
  ‚îÇ        ‚îÇ          \  
  ‚îÇ        ‚îÇ           ‚óè‚îÄ‚îÄ Centro te√≥rico (eje trasero)  
  ‚îÇ        ‚îÇ          /  
  ‚îÇ        ‚îÇ         /  
  ‚îú‚îÄ‚îÄ‚îÄ Brazo de direcci√≥n  
  ‚îÇ  
[Rueda interior (Œ∏·µ¢ > Œ∏‚Çí)]
```

---

##### **Relaci√≥n de Velocidades en Curva**

```
œâ‚Çí / œâ·µ¢ = (R + W/2) / (R - W/2)
```
- `œâ‚Çí`: Velocidad angular rueda exterior.  
- `œâ·µ¢`: Velocidad angular rueda interior.  
- `R`: Radio de giro del centro del eje.  

---

##### **Fuerzas en Conflicto**

```mermaid
flowchart LR
    A[Motor] --> B[Diferencial]
    B --> C[Semieje der.\nRueda ext. œâ‚Çí]
    B --> D[Semieje izq.\nRueda int. œâ·µ¢]
    C --> E[Fuerza de tracci√≥n ‚Üë]
    D --> F[√Ångulo de giro Œ∏·µ¢ > Œ∏‚Çí]
    E & F --> G[Cuadro]
    G --> H{Deflexi√≥n estructural?}
    H -->|S√≠| I[P√©rdida de Ackermann]
    H -->|No| J[Comportamiento ideal]
```

> [!WARNING]
> De utilizar estos sistemas, recomendamos tener cuidado con los siguientes inconvenientes los cuales aparecieron dentro de nuestras pr√°cticas con la implementaci√≥n del mencionado sistema:

1. **Paradox Steering**:  
   - *Causa*: La tracci√≥n en la rueda interior (baja adherencia) contrarresta el √°ngulo de giro.  
   - *Soluci√≥n*: Control electr√≥nico (freno vectorial).  

2. **Fatiga en semiejes**:  
   - *Causa*: Torsi√≥n excesiva en juntas homocin√©ticas debido a Œ∏·µ¢ m√°ximo + par motor.  
   - *Soluci√≥n*: Semiejes asim√©tricos con √°ngulos de trabajo optimizados.  

---

##### Soluciones de Ingenier√≠a
-  **Estrategias Recomendadas**

| **Componente**   | **Innovaci√≥n**                                    | **Beneficio**                                  |
|------------------|--------------------------------------------------|-----------------------------------------------|
| **Cuadro**       | Subchasis desmontable con rigidez variable.      | Permite ajustes finos en competici√≥n.         |
| **Diferencial**  | Electr√≥nico con mapas por √°ngulo de giro.        | Regula par seg√∫n Œ∏·µ¢/Œ∏‚Çí (ej: Honda SH-AWD).   |
| **Direcci√≥n**    | Brazo de Ackermann ajustable (r√≥tulas roscadas). | Compensa desgaste o cambios de neum√°ticos.    |

--- 


[![Ackermann-turning-svg.png](https://i.postimg.cc/CL08P93k/Ackermann-turning-svg.png)](https://postimg.cc/8syssXPz)

El n√∫cleo de la movilidad de nuestro robot reside en su **subsistema mec√°nico de transmisi√≥n y tracci√≥n**, cuidadosamente seleccionado con componentes espec√≠ficos de alta calidad. Vamos a desglosar c√≥mo cada pieza encaja en este rompecabezas de ingenier√≠a en miniatura, usando la escala **1/18** como referencia clave para tama√±o e integraci√≥n:

1.  **Diferenciales y Ejes de Transmisi√≥n (1/18)**

[![61-Gzbd9-XBj-L-AC-UF894-1000-QL80.jpg](https://i.postimg.cc/7ZqxBpWR/61-Gzbd9-XBj-L-AC-UF894-1000-QL80.jpg)](https://postimg.cc/Cz6T56YC)

---

Los diferenciales se ubican en el eje motriz y permiten que las ruedas izquierda y derecha giren a velocidades diferentes al tomar curvas. Esta caracter√≠stica es fundamental para evitar que el robot patine o experimente esfuerzos innecesarios en giros cerrados, manteniendo as√≠ la estabilidad incluso durante maniobras agresivas. Su dise√±o a escala 1/18 asegura que sean compactos, ligeros y proporcionales al resto del chasis y ruedas del robot de competici√≥n.

Por otro lado, los ejes de transmisi√≥n conectan directamente la salida de los diferenciales (1/18) a las ruedas motrices. Son responsables de transferir el par motor generado hacia las ruedas, permitiendo el giro de los neum√°ticos. El dise√±o a escala 1/18 garantiza la longitud y resistencia necesarias para soportar las fuerzas de torsi√≥n y tracci√≥n, sin a√±adir peso excesivo ni desbalancear el robot.

En el caso particular del robot Heimdall, originalmente se consider√≥ una transmisi√≥n 4x4. Sin embargo, tras observar las limitaciones en los √°ngulos de cruce y la maniobrabilidad, se opt√≥ por priorizar la movilidad. Por ello, se decidi√≥ retirar los ejes de transmisi√≥n delanteros, transformando el robot en un sistema de tracci√≥n 4x2.

---

#### Diferencias mas importantes entre transmisi√≥n 4x4 y 4x2 

| Caracter√≠stica                  | 4x4 (Tracci√≥n en las 4 ruedas)            | 4x2 (Tracci√≥n en 2 ruedas)                  |
|----------------------------------|-------------------------------------------|---------------------------------------------|
| **Motricidad**                  | Alta, ideal para terrenos irregulares o cruces complejos. | Moderada, suficiente para la mayor√≠a de maniobras en pista controlada. |
| **√Ångulo de cruce**             | Limitado por la presencia de ejes delanteros. | Mayor libertad de giro y mejor √°ngulo de cruce. |
| **Estabilidad en curvas**       | M√°s estable en condiciones extremas.       | Buena estabilidad, pero depende m√°s del dise√±o del chasis y el diferencial. |
| **Peso total**                  | Mayor, por la cantidad extra de componentes (ejes y diferenciales delanteros). | Menor, lo que contribuye a una mejor relaci√≥n peso-potencia.              |
| **Complejidad mec√°nica**        | M√°s alta; requiere mayor mantenimiento y ajuste. | M√°s sencilla, facilita el mantenimiento y reduce fallos mec√°nicos.         |
| **Consumo energ√©tico**          | M√°s elevado por la transmisi√≥n a cuatro ruedas. | Menor, lo que puede aumentar la autonom√≠a.                                |
| **Aplicaci√≥n recomendada**      | Terrenos dif√≠ciles, obst√°culos, m√°xima tracci√≥n. | Pistas controladas, mayor maniobrabilidad y agilidad.                     |

2. **INJORA 7KG 2065 Digital Micro Servo**

El servo INJS2065 es un Servomotor compacto y de alto rendimiento, ideal para aplicaciones de rob√≥tica y modelismo a escala. A la hora de tener en cuenta tanto eficiencia como el manejo del espacio en un sistema embebido como el de un robot, el INJS2065 se destaca por sobre otros modelos. as√≠ como tambi√©n destaca por su r√°pida velocidad de respuesta, alta precisi√≥n en el control de √°ngulo y considerable torque de retenci√≥n. lo mencionado ut supra le permite operar eficientemente bajo diversas condiciones de carga. Su amplio rango de voltaje de operaci√≥n, junto con un motor de n√∫cleo y rodamientos de bolas, asegura durabilidad, flexibilidad y un funcionamiento suave, mientras que su tama√±o reducido facilita su integraci√≥n en dise√±os que requieren soluciones ligeras y confiables.

[![IMG-1126-1200x1200.jpg](https://i.postimg.cc/52JgQgQr/IMG-1126-1200x1200.jpg)](https://postimg.cc/bs6kKQT0)

| :wrench: **Especificaciones del Servo INJS2065** |                                                            |
|:------------------------------------------------|:----------------------------------------------------------:|
| **Banda muerta**                                | 2 Œºs                                                       |
| **Posici√≥n neutral**                            | 1500 Œºs / 330 Hz                                           |
| **Tipo de motor**                               | Motor de n√∫cleo                                            |
| **√Ångulo control remoto**                       | 90-120¬∞ ¬±2¬∞                                                |
| **√Ångulo (500-2500 Œºs)**                        | 180¬∞ ¬±2¬∞                                                   |
| **Rango de voltaje**                            | 4.8V - 8.4V                                                |
| **Velocidad de operaci√≥n (6.0V)**               | 0.09 s/60¬∞                                                 |
| **Velocidad de operaci√≥n (8.4V)**               | 0.06 s/60¬∞                                                 |
| **Torque de retenci√≥n (6.0V)**                  | 6.0 kg¬∑cm / 83.3 oz¬∑in                                     |
| **Torque de retenci√≥n (8.4V)**                  | 7.0 kg¬∑cm / 97.2 oz¬∑in                                     |
| **Dimensiones**                                 | 23 √ó 13 √ó 25.8 mm                                          |
| **Peso**                                        | 20 g                                                       |
| **Longitud del cable conector**                 | JR 300 mm                                                  |
| **Rodamientos**                                 | 1BB                                                        |
| **Peso con empaque**                            | 28 g                                                       |
| **Tama√±o del paquete**                          | 36 √ó 23 √ó 38 mm                                            |

---

| :wrench: **Herramientas requeridas**            |                                                            |
|:------------------------------------------------|:----------------------------------------------------------:|
| 1 √ó Destornillador hexagonal 1.5 mm             |                                                            |
| 1 √ó Destornillador hexagonal 2.0 mm             |                                                            |


3. ### Motor DC 12V Greartisan zga37irg9i

[![61pi-8-J6q-L.jpg](https://i.postimg.cc/C5wWw8pB/61pi-8-J6q-L.jpg)](https://postimg.cc/LY0yTnX2)


Un Motor de Engranajes DC Greartisan es un tipo de motor el√©ctrico de corriente continua (DC) que tiene una caja de engranajes (tambi√©n llamada reductora o caja reductora) integrada directamente en su construcci√≥n. La principal funcionalidad de este motor en un sistema rob√≥tico radica en su capacidad para ofrecer **alto par a velocidades reducidas**. A diferencia de un motor DC est√°ndar que gira a muy altas RPM con poco par, el motor Greartisan integra una **caja de engranajes** (reductora) directamente en su dise√±o. Esta caja de engranajes transforma la velocidad de rotaci√≥n del motor en una fuerza mucho mayor.
 El **eje de salida c√©ntrico de 1.45 pulgadas de di√°metro** proporciona una conexi√≥n robusta y directa a los sistemas mec√°nicos del robot, como ruedas, brazos articulados o mecanismos de elevaci√≥n, asegurando que el par generado se transmita de manera eficiente.

> [!TIP]
>  Evita los movimientos bruscos y dif√≠ciles de controlar de los motores de alta velocidad sin reducci√≥n.
>     Aunque parezca contradictorio, al operar con una relaci√≥n de engranajes adecuada, el motor puede trabajar m√°s cerca de su punto de eficiencia √≥ptima para la carga que est√° manejando, lo que puede resultar en un **menor consumo de energ√≠a** en comparaci√≥n con un motor sin engranajes que lucha por alcanzar el par requerido.

### Especificaciones del Motor

| **Caracter√≠stica**                          | **Valor**                                         |
|---------------------------------------------|---------------------------------------------------|
| **Voltaje nominal**                         | 12V                                               |
| **Velocidad**                               | 10 RPM                                            |
| **Material**                                | Metal                                             |
| **Par nominal**                             | 33.1 lbs¬∑cm                                       |
| **Relaci√≥n de reducci√≥n interna**           | 1:314                                             |
| **Corriente nominal**                       | 0.05A                                             |
| **Tama√±o del eje de salida (forma D)**      | 6 √ó 14 mm (0.24" √ó 0.55") (D √ó L)                 |
| **Tama√±o de la caja de cambios**            | 37 √ó 31 mm (1.46" √ó 1.22") (D √ó L)                |
| **Tama√±o del motor**                        | 36.2 √ó 33.3 mm (1.43" √ó 1.31") (D √ó L)            |

### C√°lculo de la reducci√≥n total

Para adaptar la salida del motor a las necesidades del robot, realizamos un c√°lculo de la reducci√≥n total combinando la reducci√≥n interna del motor con la de un sistema de engranajes externo. Utilizamos un pi√±√≥n de ataque est√°ndar (acoplado al eje del motor) y engranajes de 17 y 28 dientes.

La relaci√≥n de reducci√≥n adicional por engranajes se calcula as√≠:
- Si el pi√±√≥n tiene, por ejemplo, 10 dientes, y el engranaje acoplado tiene 28 dientes, la reducci√≥n es 28/10 = 2.8.
- Si se agregan m√°s etapas de engranajes (por ejemplo, usando un engranaje intermedio de 17 dientes), la reducci√≥n se multiplica por cada etapa.

La reducci√≥n total del sistema es:

```
Reducci√≥n total = Reducci√≥n interna del motor √ó (dientes engranaje grande / dientes pi√±√≥n)
```

 Usando engranajes de 17 y 28 dientes y un pi√±√≥n (Calculo de nuestro robot)
```cpp
Reducci√≥n total = 2.23 x 2.55 = 5.6865 
```

```cpp
Revoluciones totales = 550 / 5.6865 = 96.7rpm
```

### ¬øPor qu√© es importante la reducci√≥n?

Dos palabras clave: `Velocidad` y `Torque`. Al aumentar la reducci√≥n, la velocidad de salida disminuye, permitiendo un control m√°s preciso del robot, y paralelamente  La reducci√≥n aumenta el torque disponible en las ruedas, lo que mejora la capacidad de mover el robot o superar obst√°culos.

### Razones para elegir este motor y sistema de reducci√≥n

- **Versatilidad y control:** El motor de 12V es est√°ndar y confiable. La reducci√≥n interna m√°s la reducci√≥n por engranajes externos se adapta perfectamente a las necesidades del robot.
- **Adaptabilidad:** Cambiando los engranajes externos se puede ajustar f√°cilmente la velocidad y el torque final.
- **Eficiencia y disponibilidad:** Los componentes son f√°ciles de conseguir y econ√≥micos.

---

4.  **Tornillos, Tuercas de Seguridad y Arandelas (M2 y M3)**

[![71jo-Lr4ep-SL-AC-UF894-1000-QL80.jpg](https://i.postimg.cc/Hk0rnwfq/71jo-Lr4ep-SL-AC-UF894-1000-QL80.jpg)](https://postimg.cc/cvHx5n1h)

 ##### Ya sean M2 o M3, son piezas imprescindibles para la mecanica de nuestro robot, debido a la fijacion de piezas peque√±as, estabilizaci√≥n de componentes, y la garant√≠a de seguridad que otorgan con respecto al uso prolongado del robot ya sea en practicas o en la competici√≥n.
 ##### Se decidi√≥ tomar la decisi√≥n de tener tornillos M2 y M3 de forma simult√°nea para velar por la eficiencia del espacio, para permitir compatibilidad con los componentes m√°s peque√±os, y al mismo tiempo para garantizar que los tornillos resistan y permitan estabilidad en el robot.
     
---

### Apartado Electronico

Para el proyecto, decidimos usar;

#### **Bater√≠as**

[![61ke-U06-D5v-L-UF1000-1000-QL80-FMwebp.webp](https://i.postimg.cc/G902qrBx/61ke-U06-D5v-L-UF1000-1000-QL80-FMwebp.webp)](https://postimg.cc/K3Nx86D1)

##### Dise√±adas para potenciar el rendimiento en competiciones de rob√≥tica como la WRO, las bater√≠as Tenergy NiMH de 12 V y 2000 mAh ofrecen dos ventajas cr√≠ticas: su ausencia de efecto memoria garantiza m√°xima capacidad en cada uso tras recargas frecuentes (ideal para sesiones de prueba extensas), y su formato compacto (1.969x1.142x2.835 pulgadas) con cables desnudos facilita la integraci√≥n en espacios reducidos de robots. Con carga r√°pida ‚â§1A y larga vida √∫til, son una soluci√≥n fiable para  cuando necesitemos usarlas por un tiempo prolongado, ya sea en la propia competici√≥n o en pruebas.

> [!TIP]
> Para maximizar rendimiento y seguridad en robots**, cargue siempre estas bater√≠as con un cargador compatible NiMH (como el Tenergy 6V-12V) a ‚â§1A para evitar sobrecalentamiento y prolongar su vida √∫til (~500 ciclos). Durante competiciones WRO, monitoree la temperatura (detenga si supera 45¬∞C) y verifique el voltaje post-uso (>10.8V ideal); evite descargas profundas (<0.9V/celda) recargando tras 3-4 sesiones. Almac√©nelas con 40-60% de carga en ambiente fresco (15-25¬∞C), realice mantenimiento cada 4 semanas si no se usan, y en robots proteja el pack contra golpes con aislante anti-vibraci√≥n. 

| Caracter√≠stica                         | Detalle                                   |
|-----------------------------------------|-------------------------------------------|
| Dimensiones del producto                | 2,13 x 2,91 x 1,22 pulgadas               |
| ASIN                                    | B077Y9HNTF                                |
| N√∫mero de modelo del producto           | 19676                                     |
| Pilas                                   | 10 12V (Tipo de pila necesaria)           |
| Opini√≥n media de los clientes           | 4.5 de 5 estrellas (748 opiniones)        |
| Clasificaci√≥n en los m√°s vendidos       | n¬∫108,878 en Salud y Hogar                |
|                                         | n¬∫250 en Pilas 12 V                       |
| Descatalogado por el fabricante         | No                                        |
| Producto en amazon.com desde            | marzo 10, 2018                            |
| Voltaje                                 | 12 Voltios                                |
| Reutilizaci√≥n                           | Recargable                                |
| Peso de la bater√≠a                      | 225 Gramos                                |
| Dimensiones del art√≠culo LxWxH          | 2,13 x 2,91 x 1,22 pulgadas               |
| Peso del art√≠culo                       | 255 Gramos                                |
| Amperaje                                | 1 Amperios                                |
| UPC                                     | 844949030014                              |
| Fabricante                              | Tenergy                                   |
 cuadro de info

### **LM2596**  
##### El LM2596 es un regulador step down DC-DC dise√±ado para transformar tensiones elevadas en niveles adecuados para circuitos electr√≥nicos.  Acepta un rango de entrada entre 3.2 y 40V, Lo cual evidentemente demuestra que es un componente electr√≥nico bastante vers√°til en lo que al manejo de voltaje respecta, por lo tanto nuestro equipo decidi√≥ utilizarlo para poder manejar el voltaje en el circuito del robot de forma id√≥nea.

---

### **üìä Cuadro Resumen del Datasheet**  
| **Par√°metro**             | **Valor/Descripci√≥n**                  | **Puntos Relevantes**                                                          |     |
| ------------------------- | -------------------------------------- | ------------------------------------------------------------------------------ | --- |
| **Rango de entrada**      | 3.2‚Äì40 V DC                            | Compatible con bater√≠as LiPo (7.4V), Pb-√°cido (12V), o paneles solares.        |     |
| **Rango de salida**       | 1.25‚Äì37 V DC ajustable                 | Ideal para microcontroladores (5V), sensores (3.3V) o motores (6‚Äì12V).         |     |
| **Corriente m√°xima**      | 3 A (pico), 2 A continuo sin disipador | Suficiente para servomotores, drivers de motores, o sistemas de control.       |     |
| **Eficiencia**            | Hasta 92% , ‚âà73% @3A                   | Reduce p√©rdidas t√©rmicas vs. reguladores lineales, crucial en sesiones largas. |     |
| **Frecuencia**            | 150 kHz                                | Permite usar componentes magn√©ticos peque√±os (compacto).                       |     |
| **Temperatura operativa** | -40¬∞C a +85¬∞C                          | Funciona en entornos extremos (competiciones exteriores).                      |     |
| **Dimensiones**           | 45√ó20√ó14 mm (est√°ndar)                 | F√°cil integraci√≥n en espacios reducidos de robots.                             |     |
| **Protecciones**          | Limitaci√≥n de corriente                | Previene da√±os por cortocircuitos en cables o motores.                         |     |
|                           |                                        |                                                                                |     |

---

### ** Funcionamiento T√©cnico**  
El LM2596 sigue una topolog√≠a **buck cl√°sica** con cuatro componentes clave:  
1. **Interruptor (MOSFET)**: Regula el flujo de energ√≠a mediante PWM a 150 kHz .  
2. **Bobina (inductor)**: Almacena energ√≠a magn√©tica durante el ciclo "ON" y la libera en el "OFF", estabilizando el voltaje .  
3. **Diodo**: Cierra el circuito durante la fase de descarga de la bobina .  
4. **Capacitor**: Filtra rizados (<50 mV ), crucial para microcontroladores sensibles al ruido.  

> [!TIP]
>     - Usar disipador si la corriente supera 1.5A .  
>  - Monitorear temperatura con term√≥metro IR (>45¬∞C indica riesgo) .  
  - Mantener diferencia m√≠nima de **1.5V entre entrada/salida** (ej: 7.4V entrada ‚Üí 5V salida) .  
  - Para motores, agregar un **fusible de 2‚Äì3A** en serie .    
  - Usar cables AWG 18+ para corrientes >2A .  
  - Evitar loops largos en entrada/salida para reducir rizado.  

---


[![images-20.jpg](https://i.postimg.cc/j2fgHz4h/images-20.jpg)](https://postimg.cc/RJML9J83)


#### Driver L298N

foto toto

Es un **controlador de motores de doble puente H (dual H-bridge)** encapsulado en un circuito integrado. Su funci√≥n principal es actuar como un "intermediario de potencia" entre dispositivos de control de baja potencia (como Arduino) y motores de alta potencia (como tu motor DC 12V).

**Es extremadamente √∫til para nuestro proyecto debido a su:**

1. **Amplificaci√≥n de corriente:**  
   - Los microcontroladores solo pueden entregar ~20-40mA por pin.  
   - El L298N soporta hasta **2A por canal** (suficiente para motores medianos).  
2. **Control direccional:**  
   - Permite invertir la polaridad del voltaje aplicado al motor para cambiar su giro (adelante/atr√°s).  
3. **Protecci√≥n el√©ctrica:**  
   - A√≠sla el circuito de control de los picos de voltaje generados por el motor.  
4. **Manejo de alta tensi√≥n:**  
   - Soporta motores de 5V a 35V (ideal para tu motor 12V).  

---

#### **Partes clave del m√≥dulo L298N:**  
| **Componente**      | **Funci√≥n**                                                                 |
|---------------------|-----------------------------------------------------------------------------|
| **Puertos de salida** (OUT1, OUT2, OUT3, OUT4) | Conectan los motores (2 motores DC o 1 motor paso a paso).                  |
| **Entradas l√≥gicas** (IN1, IN2, IN3, IN4) | Reciben se√±ales de control desde Arduino (determinan direcci√≥n).          |
| **Pines de habilitaci√≥n** (ENA, ENB) | Activan/desactivan los canales (con/sin PWM).                             |
| **Regulador de 5V** | Provee energ√≠a a la l√≥gica (puede alimentar al Arduino si se usa el jumper).|
| **Disipador de calor** | Met√°lico, previene sobrecalentamiento durante uso prolongado.             |
| **Jumpers**         | Configuran el modo de operaci√≥n (ej: habilitaci√≥n permanente de canales). |

---

#### **¬øC√≥mo controla un motor DC?**  
Usa un circuito **puente H (H-bridge)** interno:  
``` 
   [IN1] --[SW1]---- Motor ----[SW3]-- [IN2]  
               |                   |  
              [SW2]               [SW4]  
```  
- **Giro adelante:**  
  `IN1 = HIGH` (SW1 cerrado) + `IN2 = LOW` (SW4 cerrado) ‚Üí Corriente fluye: SW1 ‚Üí Motor ‚Üí SW4  
- **Giro atr√°s:**  
  `IN1 = LOW` (SW2 cerrado) + `IN2 = HIGH` (SW3 cerrado) ‚Üí Corriente fluye: SW3 ‚Üí Motor ‚Üí SW2  
- **Frenado:**  
  `IN1 = HIGH` + `IN2 = HIGH` ‚Üí Cortocircuito en bornes del motor (frena r√°pidamente).  

---


#### Sensores Ultras√≥nicos 

[![D-NQ-NP-986330-MLV79479843776-102024-O.webp](https://i.postimg.cc/J0w9gkPq/D-NQ-NP-986330-MLV79479843776-102024-O.webp)](https://postimg.cc/N94J25h9)

##### El robot cuenta con m√∫ltiples sensores ultras√≥nicos (HC-SR04) ubicados estrat√©gicamente para la detecci√≥n de obst√°culos y el c√°lculo de distancias, permitiendo navegaci√≥n aut√≥noma y segura. El sensor HC-SR04 es un sensor de distancia de bajo costo, por lo que su uso es muy frecuente en la rob√≥tica. Incorpora un par de transductores de ultrasonido que se utilizan de manera conjunta para determinar la distancia del sensor con un objeto colocado frente a este. Un transductor emite una r√°faga de ultrasonido y el otro capta el rebote de dicha onda.

> [!NOTE]
> El tiempo que tarda la onda sonora en ir y regresar a un objeto puede utilizarse para conocer la distancia entre el origen del sonido y el objeto. La interfaz del sensor HC-SR04 y Arduino se logra mediante 2 pines digitales: el pin de disparo (trigger) y el pin de eco (echo). La funci√≥n de cada uno de estos pines es la siguiente:
- El pin trigger recibe un pulso de habilitaci√≥n del microcontrolador, mediante el cual se le indica al m√≥dulo que comience a realizar la medici√≥n de distancia.
- En el pin echo el sensor devuelve al microcontrolador un pulso cuyo ancho es proporcional al tiempo que tarda el sonido en viajar del transductor al obst√°culo y luego de vuelta al m√≥dulo

- mas info

#### Pixy2

<fotos del entrenamiento de signatures, librer√≠as, mucha paja

### Conexiones y Circuitos

##### Todos los m√≥dulos est√°n conectados en un circuito organizado, minimizando interferencias y facilitando el mantenimiento.  

#### Diagramas de Flujo

##### En este diagrama de flujo se halla una representaci√≥n gr√°fica del funcionamiento l√≥gico de nuestra programaci√≥n, as√≠ como de lo que se espera sea el desempe√±o del robot al inicializar el programa.

##### Desaf√≠o Abierto

```mermaid
flowchart LR
    A[Inicio] --> B[Esperar bot√≥n de inicio]
    B -- Bot√≥n presionado --> C[Iniciar programa]
    C --> D[Contador de giros < 12?]
    D -- No --> E[Avanzar 1.5s y detenerse]
    E --> F[Fin]
    D -- S√≠ --> G[Leer sensores ultras√≥nicos]
    G --> H{¬øFrontal > 20cm?}
    H -- S√≠ --> I[Avanzar recto]
    I --> J{¬øEn tiempo de espera tras giro?}
    J -- S√≠ --> G
    J -- No --> K{¬øIzquierda > 200cm?}
    K -- S√≠ --> L[Girar izquierda, +1 giro, reset tiempo]
    L --> I
    K -- No --> M{¬øDerecha > 200cm?}
    M -- S√≠ --> N[Girar derecha, +1 giro, reset tiempo]
    N --> I
    M -- No --> I
```

##### Desaf√≠o Cerrado

```mermaid
flowchart LR
    A([Inicio]) --> B([void setup])
    B --> C{¬øBot√≥n presionado?}
    C -- No --> C
    C -- S√≠ --> D([programaIniciado = true])
    D --> E([void loop])
    E --> F{¬øfinalizado?}
    F -- S√≠ --> G([Termina])
    F -- No --> H([doceGiros])
    H --> I[Lectura sensores]
    I --> J{¬øPixy2 detecta bloques?}
    J -- S√≠ --> K([goToPosition])
    J -- No --> L{¬øObst√°culo al frente?}
    L -- No --> M{¬øEspacio libre?}
    M -- S√≠ --> N[Girar o avanzar]
    M -- No --> O[Parar]
    L -- S√≠ --> O
    K --> G
    N --> G
    O --> G
```

#### Diagrama de Conexiones 

#### Microcontroladores

##### ESP-32

[![esp32-wroom-32e.jpg](https://i.postimg.cc/mDT9SXGN/esp32-wroom-32e.jpg)](https://postimg.cc/f3gkzvyJ)

##### El **ESP32-WROOM** es un m√≥dulo todo-en-uno potente y econ√≥mico basado en el chip ESP32, que integra un **procesador dual-core de hasta 240 MHz**, **Wi-Fi 802.11 b/g/n (2.4 GHz)**, y **Bluetooth (Cl√°sico y BLE)**, junto con **4 MB de memoria flash SPI y 520 KB de RAM** en el mismo encapsulado, adem√°s de una antena PCB integrada; ofrece m√∫ltiples perif√©ricos (GPIOs, ADC, DAC, UART, SPI, I2C, PWM, etc.), soporta modos de bajo consumo para bater√≠as, y es ideal para proyectos de IoT, dom√≥tica, rob√≥tica o interfaces, siendo f√°cil de programar con Arduino IDE, ESP-IDF o MicroPython.
##### Adem√°s del microcontrolador, tambi√©n es necesario tener un buen entorno con las librer√≠as necesarias para compilar y interpretar el c√≥digo, y eventualmente crear un ecosistema √≥ptimo para nuestro robot. Por esto, hemos decidido utilizar 4 librer√≠as esenciales para lograr nuestro objetivo:

1.  **`Wire.h` (Comunicaci√≥n I¬≤C):**  
    Esencial para conectar sensores, pantallas (OLED) o memorias (EEPROM) que usen el bus I¬≤C. Con `Wire.begin(SDA, SCL)` configuras los pines, luego usas `Wire.beginTransmission()`, `Wire.write()`, `Wire.read()` y `Wire.endTransmission()` para enviar/recibir datos. A partir de esta librer√≠a establecemos comunicaci√≥n con el ESP-32.

2.  **`Ultrasonic.h` (Sensor de Distancia):**  
    Simplifica el uso de sensores como el HC-SR04. Con `Ultrasonic ultrasonic(TRIG, ECHO)` inicializas, y `ultrasonic.read()` devuelve la distancia en cm. Ideal para evadir los obst√°culos de la pista y evitar colisiones con las paredes ya sean internas o externas. As√≠ como sistemas de estacionamiento o cualquier proyecto que requiera detecci√≥n de proximidad sin contacto, manejando autom√°ticamente los pulsos de medici√≥n.

3.  **`ESP32Servo.h` (Control de Servomotores):**  
    Librer√≠a espec√≠fica para manejar servos en el ESP32, ya que los timers PWM son distintos a Arduino. Con `servo.attach(PIN)` configuras y `servo.write(grados)` posicionas el servo (0¬∞-180¬∞). Crucial para manejar automatismos y conseguir movimiento angular preciso con motores de bajo torque.

4.  **`PixySPI2.h` (C√°mara Inteligente Pixy2):**  
    Facilita la comunicaci√≥n con la c√°mara Pixy2 (v√≠a SPI) para visi√≥n artificial simple. Detecta objetos por color, formas (bloques) o l√≠neas. Usas `pixy.init()` y `pixy.ccc.getBlocks()` para obtener datos. A partir de la pixy, podemos crear c√≥digo que pueda identificar los bloques verdes, rojos, y el estacionamiento magenta para que act√∫e acorde y pueda realizar el desaf√≠o cerrado.

### ¬øPor qu√© Pixy2SPI.h?

 La decisi√≥n entre usar **`Pixy2SPI.h`** (comunicaci√≥n SPI) o **`Pixy2.h`** (comunicaci√≥n I2C) fue un problema con el que nos encontramos apenas comenzamos a utilizar la PixyCam‚Ñ¢. En nuestra experiencia, podemos declarar que el protocolo de comunicaci√≥n SPI transmite datos de forma m√°s r√°pida que mediante I¬≤C, y por tanto creemos que vale la pena el elegir Pixy2SPI para poder recibir `signatures`
y datos apenas la pixy los procese

### **1. Rendimiento y Velocidad**  
- **`Pixy2SPI.h` (SPI)**:  
  - **Velocidad m√°xima**: Hasta **10 Mbps** (dependiendo del microcontrolador).  
  - **Ventaja**: Ideal para aplicaciones que requieren **alta velocidad** (ej: robots en competiciones, procesamiento en tiempo real).  
  - SPI es **full-duplex**, permitiendo transmisi√≥n y recepci√≥n simult√°neas.  

- **`Pixy2.h` (I2C)**:  
  - **Velocidad m√°xima**: T√≠picamente **400 kHz** (modo est√°ndar) o **1 MHz** (modo r√°pido).  
  - **Limitaci√≥n**: Puede causar cuellos de botella si se transfieren muchos bloques/objetos por fotograma.  

> [!WARNING] 
> ‚òëÔ∏è **Elige SPI si:** Necesitas m√°xima velocidad (ej: seguimiento de objetos r√°pidos, FPS alto).
> 
> ‚òëÔ∏è**Elige SPI si:** Trabajas en entornos el√©ctricamente ruidosos (un robot de la WRO)

---

#### Otras razones por las cuales el protocolo SPI nos result√≥ favorable en testeo y ejecuci√≥n de la PixyCam en pista:

##### **SPI**:  
  - **Menos susceptible a ruido** gracias a se√±ales de reloj dedicadas y conexiones punto a punto.  
  - Ideal para entornos con motores o fuentes de interferencia (ej: competiciones **FIRST Robotics**).  

##### **I2C**:  
  - M√°s sensible al ruido debido a su dise√±o multi-dispositivo en 2 cables.  
  - Puede requerir pull-up resistors adicionales para evitar fallos.  

---

### Apartado Programatico

#### Codigo por Componente

##### Desaf√≠o Abierto

- En cuanto al c√≥digo utilizado para manejar el robot, consiste en una parte en la que se definen los pines del ESC y de los ultras√≥nicos. Dentro del c√≥digo se arma el ESC, se inicializan los sensores y se inicializa una funci√≥n llamada "doceVueltas", la cual se encarga de hacer una lectura constante de los sensores ultras√≥nicos para decidir en qu√© momento girar, as√≠ como de registrar los giros para que el robot se detenga al completar exitosamente 3 vueltas.

En este apartado se inicializa el motor, y se prepara el robot para ejecutar la funci√≥n que sigue:
```cpp
void setup() {
  myservo.attach(PIN_SERVO);
  Serial.begin(115200);

  pinMode(PIN_BOTON, INPUT_PULLUP);  // Bot√≥n con resistencia interna pull-up
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);

  digitalWrite(IN1, LOW);     
  digitalWrite(IN2, LOW); 
  myservo.write(99);  // Servo centrado
  delay(3000);

  Serial.println("Esperando pulsar bot√≥n para iniciar...");
```

Y en este, se llama a la funci√≥n de doceGiros, la cual ejecuta los giros y ajustes espec√≠ficos del robot 

```cpp
void docegiros() {
  unsigned long ahora = millis();

  int frontal = USFront.read();
  int izquierda = USLeft.read();
  int derecha = USRight.read();

  if (frontal == 357) frontal = -1;
  if (izquierda == 357) izquierda = -1;
  if (derecha == 357) derecha = -1;

  Serial.print("Distancias (cm) - Frontal: ");
  Serial.print(frontal);
  Serial.print(" | Izquierda: ");
  Serial.print(izquierda);
  Serial.print(" | Derecha: ");
  Serial.println(derecha);

  if (contadorGiros >= 12) {
    // Avanzar 1 segundo m√°s y detenerse definitivamente
    if (!finalizado) {
      Serial.println("Se alcanzaron 12 giros, avanzando 1 segundo m√°s y deteni√©ndose.");
      Adelante();
      delay(1500);
      Parar();
      finalizado = true;
    }
    return;
  }

    if (frontal != -1 && frontal > DISTANCIA_OBSTACULO_FRONTAL) {
      Adelante();
      }

      if (ahora - tiempoUltimoGiro < TIEMPO_ESPERA_GIRO) {
        Serial.println("Avanzando recto despu√©s del giro, sin girar");
      } else {
        if (izquierda != -1 && izquierda > DISTANCIA_OBSTACULO_LATERAL) {
          Serial.println("Girando a la izquierda por m√°s de 190 cm libres");
          delay(500);
          Izquierda();
          contadorGiros++;
          tiempoUltimoGiro = millis();
          Adelante();
        } else if (derecha != -1 && derecha > DISTANCIA_OBSTACULO_LATERAL) {
          Serial.println("Girando a la derecha por m√°s de 190 cm libres");
          delay(500);
          Derecha();
          contadorGiros++;
          tiempoUltimoGiro = millis();
          Adelante();
        }
      }
    } 
```

##### Desaf√≠o Cerrado

- En cuanto a la l√≥gica de programaci√≥n del Desaf√≠o Cerrado, tenemos que tomar en cuenta la detecci√≥n de colores de la Pixy, la interpretaci√≥n de datos y por √∫ltimo la reacci√≥n de los motores ante la informaci√≥n brindada por la Pixy. Primero que nada, hay que hacer un bucle en d√≥nde la Pixy lea se√±ales de bloques y dependiendo de la se√±al les asignamos un color:

```cpp

pixy.ccc.getBlocks();

if (pixy.ccc.numBlocks) {
  int y = pixy.ccc.blocks[0].m_y;
  int x = pixy.ccc.blocks[0].m_x;
  uint8_t sig = pixy.ccc.blocks[0].m_signature;

  Serial.print("Firma detectada: ");
  Serial.println(sig);
  Serial.print("Posici√≥n X: ");
  Serial.print(x);
  Serial.print(" Y: ");
  Serial.println(y);

  if (sig == 1 && y > UMBRAL_Y) {
    if (!girando) {
      girando = true;
      tiempoInicioGiro = millis();

      if (x > UMBRAL_IZQUIERDA) {
        Serial.println("Bloque verde a la derecha: Avanzar recto");
        Adelante();
        giroIzqActivo = false;
      } else {
        Serial.println("Bloque verde a la izquierda: Giro suave izquierda");
        giroIzquierdaSuave();
        giroIzqActivo = true;
      }
    } else {
      Adelante();
    }
  } else {
    if (girando && millis() - tiempoInicioGiro >= TIEMPO_GIRO_SUAVE) {
      if (giroIzqActivo) {
        Serial.println("Correcci√≥n giro derecha para enderezar");
        correccionDerecha();
      }
      girando = false;
    } else {
      Adelante();
    }
  }
} else {
  if (girando && millis() - tiempoInicioGiro >= TIEMPO_GIRO_SUAVE) {
    if (giroIzqActivo) {
      Serial.println("Correcci√≥n giro derecha para enderezar");
      correccionDerecha();
    }
    girando = false;
  } else {
    Adelante();
  }
}
```

Para luego accionar las funciones de movimiento:

```cpp
void Adelante() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  myservo.write(97);
  Serial.println("Avanzando recto");
}

void giroIzquierdaSuave() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  myservo.write(140);
  Serial.println("Girando suavemente a la izquierda");
}

void correccionDerecha() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  myservo.write(30);
  delay(TIEMPO_CORRECCION);
  myservo.write(97);
  Serial.println("Correcci√≥n giro derecha completada");
}
```
Dentro de `Desafio-abierto.ino` y `Desafio-cerrado.ino` est√° el resto de funciones descritas, y la l√≥gica de programaci√≥n mediante la cual el robot completa el desaf√≠o abierto y cerrado.

#### Compiladores y Comunicacion

- **Lenguaje principal:** C++ (Arduino IDE)
- **Compilador:** [Arduino IDE](https://www.arduino.cc/en/software- **Comunicaci√≥n entre m√≥dulos:** Bus I2C

---

## Recursos para Hacer el Robot

### Mec√°nico
- Diferenciales 1/28
- Ejes de Transmisi√≥n 1/18
- Motor Brushed Injora 180¬∞ 48T
- Ruedas de Drift 1/18
- Tuercas de Seguridad M2
- Tornillos M3
- Incertos Roscados M2
- Nudillos de Cruce
- Rolineras
- Urgenex Li-Ion 3000mAh
### Electr√≥nico 
- ESC
- ESP-32
- MPU6050
- Ultras√≥nicos HSR04
### Programaci√≥n 
- Open-Challenge.ino
- Closed-Challenge.ino

---

> _¬øQuieres contribuir o seguir nuestro avance? S√≠guenos en nuestras redes oficiales y revisa este repositorio para novedades y recursos._

---
